# React

## 知识点

### 基本使用



## JSX语法

### 语法要求

- 标签要闭合
- 元素必须要有一个顶层元素
- 变量首字母大写代表组件，小写对应是js数据类型
- 属性名，小驼峰命名 `<xx tabIndex="2">`
- 动态的属性值
- class名 须写成className=‘XXX’
- label标签 for属性写成htmlFor
- style接收一个对象
- 循环列表必须加入key值，不推荐使用index

### 基本语法

```
<header>
  <h1>Hello React!</h1>
</header>
```

### 插值表达式

> {} （表达式 ：运行后返回一个值的代码片段）

```javascript
const a = 'hello world!'

function App() {
  return <div>{a}</div>
}
```

### 注释

```
{/* 推荐单行注释符号 */}

{
  /*
    推荐多行行注释符号
    推荐多行行注释符号
    */
}

{
  // {}
  // 不推荐这样写注释
  // 注释
}
```

### 数据类型表现

* 字符串、数字：原样输出
* 布尔值、null、undefined会被忽略
* 数组  *循环列表*
* 对象  *error*
* 函数  函数返回值必须数组

### 条件渲染

```
{flag ? <h1>正确</h1> : <h1>错误</h1>}
{flag && <h1>正确</h1>}
{flag || <h1>错误</h1>}
```

### 循环列表

* 列表必须加入key值
* 如果数据列表有可能发生改变，key值不建议用index（数据驱动：id）

```
// eg1: jsx数组
const arr = [
  <p>一</p>,
  <p>二</p>,
  <p>三</p>,
]

<div>
  {arr}
</div>

// eg2: 普通数组
const data = [1, 2, 3]

<div>
  {data.map(item => <p>{item}</p>)}
</div>

// eg3: 对象
const obj = {
  first: { id: 0, name: 'zs'},
  second:{ id: 1, name: 'ls'},
  three:{ id: 2, name: 'ww'},
}

<div>
  {Object.keys(obj).map(item => <p>{obj[item].name}</p>)}
</div>
```



### jsx 格式规范

* style 接收一个对象

```
 <h1 style={{ color: 'red'}}>style color</h1>
```

* class需写成className

* html中的label  for替换为htmlFor

* jsx中注释

```
{
  // 单行注释
}
    
{ /* 多行注释 */ }
```

* 组件必须只且只有一个根元素
* 循环列表必须加 key 值
* 不能写字符串标签，编译时会被转译

## react 知识点

### 组件创建方式

* 函数式组件

```
import React from 'react'

function App() {
  return <div>App组件</div>
}

export default App
```

* class 类组件（常用）

```
class B extends React.Component{
  render() {
    return <div> B component</div>
  }
}
```

* 两种创建方式的区别

  * 区别：有无state和生命周期函数

  * 构造函数创建的组件： “无状态组件”， 只有props，没有自己的私有属性和生命周期

  * class关键字创建出来的组件： “有状态组件”，有自己的私有数据和生命周期
  * 无状态组件运行效率较高

  ```
  class B extends React.Component{
    constructor() {
      super()
      this.state = {} // 相当于vue中的的data
    }
    
    render() {
      return <div> B component { this.props.arr1 }</div>
    }
  }
  ```

### 组件实例属性

#### state ：实例属性

* 定义方式

  ```
  constructor(props) {
    super(props);
    this.state = {
      id: 0
    };
  }
  ```

* 使用

  ```
  <div>ID: {this.state.id}</div>
  ```

* 修改 setState

  ```
  <button onClick={this.add}> +1 </button>
  
  add = e =>{
    this.setState({
      id: this.state.id + 1
    })
  }
  ```

  

#### props：父组件传递属性

* 定义

  ```
  <B arr1 = 'abc' />
  ```

* 接收 && 使用

  * 函数式组件

    ```
    function B(props) {
      return <div> { props.arr1} </div>
    }
    ```

  * 类组件

    ```
    class B extends React.Component{
        constructor(props) {
          super(props);
          this.state = {};
        }
      render() {
        return <div> B component { this.props.arr1 }</div>
      }
    }
    ```

* 使用

#### context

#### refs

#### 

### 组件间数据传递



#### 事件绑定

1. 命名：首字母必须大写`onClick`、`onMouseOver`

2. 事件处理函数 this 指向

   * class 默认为严格模式： this 为 undefined

     ```
     <button onClick={this.handleClick}>点击一下</button>
     
     handleClick(e) {
       console.log('this:', this); // undefined
     }
     ```

   * 解决方法

     ```
     // 1. this 绑定
     constructor(props) {
       super(props);
       this.handleClick = this.handleClick.bind(this)
     }
     
     // 2. 箭头函数
     handleClick = e =>{
       console.log('this:', this);
     }
     ```

3. 为事件提供的处理函数，必须是如下格式

   ```
   onClick= { function }
   ```

4. 用的最多的事件绑定形式为：

   ```jsx
   <button onClick={ () => this.show('传参') }>按钮</button>
   
   // 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称
   show = (arg1) => {
       console.log('show方法' + arg1)
   }
   ```

## React中实现数据双向绑定

1. 为input绑定state数据
2. 监听onChange事件，通过事件对象e或ref获取value值，并通过setState更新数据

## 样式表作用域

> 默认导入样式表是全局有效

解决方案：

* 第三方样式表或全局方式表以`.css`  
* 自定义样式表使用`less`  或` sass` ，并配置webpack开始模块化

webpack配置方法：

1. 启用 css-modules

   1. 修改 `webpack.config.js`这个配置文件，为 `css-loader` 添加参数：

      ```js
      { test: /\.css$/, use: ['style-loader', 'css-loader?modules'] } // 为 .css 后缀名的样式表  启用 CSS 模块化
      ```

   2. 在需要的组件中，`import`导入样式表，并接收模块化的 CSS 样式对象：

      ```js
      import cssObj from '../css/CmtList.css' 
      ```

   3. 在需要的HTML标签上，使用`className`指定模块化的样式：

      ```jsx
      <h1 className={cssObj.title}>评论列表组件</h1>
      ```

2. 使用`localIdentName`自定义生成的类名格式，可选的参数有：

   - [path]  表示样式表 `相对于项目根目录` 所在路径
   - [name]  表示 样式表文件名称
   - [local]  表示样式的类名定义名称
   - [hash:length]  表示32位的hash值
   - 例子：`{ test: /\.css$/, use: ['style-loader', 'css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]'] }`

3. 使用 `:local()` 和 `:global()`

   - `:local()`包裹的类名，是被模块化的类名，只能通过`className={cssObj.类名}`来使用

     同时，`:local`默认可以不写，这样，默认在样式表中定义的类名，都是被模块化的类名；

   - `:global()`包裹的类名，是全局生效的，不会被 `css-modules` 控制，定义的类名是什么，就是使用定义的类名`className="类名"`

4. 注意：只有`.title`这样的类样式选择器，才会被模块化控制，类似于`body`这样的标签选择器，不会被模块化控制；